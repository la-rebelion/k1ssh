"use strict";(self.webpackChunkk1s_site_docs=self.webpackChunkk1s_site_docs||[]).push([[466],{3181:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"qbot/devops/qbclt-cli/index","title":"qbclt - QBot CLI","description":"QBot control (qbctl) is a CLI tool part of the QBot project, a bot to help developers and DevOps practitioners quickly scaffold new microservices, tools, and utilities AI supported. The CLI tool provides a set of commands to interact with the QBot SDK.","source":"@site/docs/qbot/devops/qbclt-cli/index.md","sourceDirName":"qbot/devops/qbclt-cli","slug":"/qbot/devops/qbclt-cli/","permalink":"/docs/qbot/devops/qbclt-cli/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"sidebar_label":"qbclt - QBot CLI"},"sidebar":"tutorialSidebar","previous":{"title":"Concepts","permalink":"/docs/qbot/devops/concepts"},"next":{"title":"Agentic AI for DevOps","permalink":"/docs/qbot/devops/agentic-ai/"}}');var o=n(4848),i=n(8453);const r={sidebar_position:3,sidebar_label:"qbclt - QBot CLI"},l="qbclt - QBot CLI",a={},c=[{value:"Installation",id:"installation",level:2},{value:"Usage",id:"usage",level:2},{value:"Commands",id:"commands",level:3}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsxs)(t.h1,{id:"qbclt---qbot-cli",children:[(0,o.jsx)(t.code,{children:"qbclt"})," - QBot CLI"]})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"QBot control"})," (qbctl) is a CLI tool part of the ",(0,o.jsx)(t.a,{href:"https://k1s.sh/qbot",children:"QBot project"}),", a bot to help developers and DevOps practitioners quickly scaffold new microservices, tools, and utilities AI supported. The CLI tool provides a set of commands to interact with the QBot SDK."]}),"\n",(0,o.jsx)(t.h2,{id:"installation",children:"Installation"}),"\n",(0,o.jsxs)(t.p,{children:["To install the ",(0,o.jsx)(t.code,{children:"qbclt"})," CLI, you can use either the binary or the ",(0,o.jsx)(t.code,{children:"npm"})," package."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-bash",children:"npm install -g @k1s/qbclt\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Another option is to use the ",(0,o.jsx)(t.code,{children:"npx"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-bash",children:"npx @k1s/qbclt [command] [options]\n"})}),"\n",(0,o.jsx)(t.p,{children:"The binary is available for Linux, MacOS, and Windows, to install the binary, download the latest release executing the following command:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-bash",children:"curl -L https://k1s.sh/qbclt | bash\n"})}),"\n",(0,o.jsx)(t.h2,{id:"usage",children:"Usage"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-bash",children:"qbclt [command] [options]\n"})}),"\n",(0,o.jsx)(t.h3,{id:"commands",children:"Commands"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"init"}),": Scaffold a new project with a directory structure and configuration files aligned with a ",(0,o.jsx)(t.code,{children:"helm"})," Chart and Kubernetes ",(0,o.jsx)(t.code,{children:"kustomize"})," setup. The project is created with no files, only directories and configuration files, unless a template is specified.","\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"<projectName>"}),": The name of the project."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"-t, --template [template]"}),": The template to use for the project. Default: ",(0,o.jsx)(t.code,{children:"default"}),". If not found, the default template will be used."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"clone"}),": Clone a repository from a remote URL and scaffold a new project with a directory structure and configuration files aligned with a ",(0,o.jsx)(t.code,{children:"helm"})," Chart and Kubernetes ",(0,o.jsx)(t.code,{children:"kustomize"})," setup."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"fork"}),": Fork a repository from a remote URL and scaffold a new project with a directory structure and configuration files aligned with a ",(0,o.jsx)(t.code,{children:"helm"})," Chart and Kubernetes ",(0,o.jsx)(t.code,{children:"kustomize"})," setup.","\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"<repositoryUrl>"}),": The URL of the repository to clone."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"snapshot"}),": Create a snapshot of the current project state and save it to a file. Semantically, a snapshot is a representation of the project state at a specific point in time.","\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"[snapshotName]"}),": The name of the snapshot, if not provided, a default name will be used. All the snapshots are saved in the ",(0,o.jsx)(t.code,{children:".qbot/snapshots"})," directory, and the naming convention is ",(0,o.jsx)(t.code,{children:"snapshotName-<timestamp>.yaml"}),". We encorage to use semantic versioning for the snapshot names."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"-g, --golden"}),": Save the snapshot as a golden snapshot. Golden snapshots are used as the reference for comparison."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"diff"}),": Compare the current project state with a snapshot.","\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"[snapshotName]"}),": The name of the snapshot to compare with the current project state, if not provided, the golden snapshot will be used, but if no golden snapshot is found, the latest snapshot will be used."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"rollback"}),": Rollback the project state to the golden snapshot or a specific snapshot.","\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"[snapshotName]"}),": The name of the snapshot to rollback to, if not provided, the latest snapshot will be used."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"deploy"}),": Deploy the project to a Kubernetes cluster.","\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"-e, --environment [environment]"}),": The environment to deploy the project to. Default: ",(0,o.jsx)(t.code,{children:"development"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"-r, --release [release]"}),": The release version to deploy. Default: ",(0,o.jsx)(t.code,{children:"latest"}),". In this context, the release version can be a snapshot name or a semantic version."]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>l});var s=n(6540);const o={},i=s.createContext(o);function r(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);